require 'graphviz_r'

module VizRake

  def self.init_graphviz
    @gvr = GraphvizR.new 'test'
  end
  def self.output(filename,label)
    filename ||= 'vizrake.png'
    format     = File.extname(filename)[1..-1]
    label    ||= 'Generated by VizRake'
    @gvr.graph[:label=> label]
    @gvr.output(filename,format)
  end

  def self.file(arg)
    controller(:file,arg)
  end
  def self.task(arg)
    controller(:task,arg)
  end
  def self.desc(mes)
    @mes = mes
  end

  private

  def self.controller(type,arg)
    unless arg.is_a? Hash
      node(arg) if disp_clean?(arg)
    else
      key = arg.keys[0]
      vals = arg[key]
      vals = [vals] unless vals.is_a? Array
      vals.each { |val|
        if type == :task
          node2node(key,val) if disp_clean?(key)
        elsif type == :file
          boxnode(val)
          boxnode(key)
          node2node(val,key)
        end
      }
    end
    @mes = nil
  end

  def self.node2node(node1,node2)
    @mes = '' unless disp_message?
    @mes = '' unless @mes
    (@gvr[q(node1)] >> @gvr[q(node2)]) [:label => @mes]
  end
  def self.node(node)
    @gvr[q(node)]
  end
  def self.boxnode(node)
    @gvr[q(node)] [:shape => :record]
  end

  def self.disp_clean?(task)
    return false unless task == :clean || task == :clobber
    ret = false #default
    if defined? VizRakeConf
      ret = VizRakeConf[:disp_clean]
    end
    return ret
  end

  def self.disp_message?
    ret = false
    if defined? VizRakeConf
      ret = VizRakeConf[:disp_message]
    end
    return ret
  end

  def self.q(arg) #"q" means "quote"
    %Q'"#{arg}"'
  end
end

[:task,:file,:desc].each { |method|
  # aliasing
  eval "alias :_#{((method.to_s)+"_org").to_s} :#{method}"
  # overloading
  eval(<<-EVL
    def #{method}(arg,&block)
      VizRake::#{method}(arg)
      _#{method}_org(arg,&block)
    end
  EVL
  )
}

VizRake.init_graphviz

at_exit {
  @mes = nil

  filename = label = clean = nil
  if defined? VizRakeConf
    filename = VizRakeConf[:filename]
    label    = VizRakeConf[:label]
  end

  if defined? CLEAN
    CLEAN.each { |t|
     task :clean => t
    }
  end
  if defined? CLOBBER
    CLOBBER.each { |t|
      task :clobber => t
    }
  end

  VizRake::output(filename,label)
}


